# инструкции Dockerfile
<ul>
<li>FROM — задаёт базовый (родительский) образ.</li>
<li>LABEL — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.</li>
<li>ENV — устанавливает постоянные переменные среды.</li>
<li>RUN — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.</li>
<li>COPY — копирует в контейнер файлы и папки.</li>
<li>ADD — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.</li>
<li>CMD — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD.</li>
<li>WORKDIR — задаёт рабочую директорию для следующей инструкции.</li>
<li>ARG — задаёт переменные для передачи Docker во время сборки образа.</li>
<li>ENTRYPOINT — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.</li>
<li>EXPOSE — указывает на необходимость открыть порт.</li>
<li>VOLUME — создаёт точку монтирования для работы с постоянным хранилищем.</li>

</ul>

# полезные советы

<p>Слои в итоговом образе создают только инструкции FROM, RUN, COPY, и ADD
Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать, например — открыть какой-то порт или выполнить какую-то команду.</p>

<ul>
<li>В одном файле Dockerfile может присутствовать лишь одна инструкция CMD. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней.</li>
<li>Инструкция CMD может иметь exec-форму. Если в эту инструкцию не входит упоминание исполняемого файла, тогда в файле должна присутствовать инструкция ENTRYPOINT. В таком случае обе эти инструкции должны быть представлены в формате JSON.</li>
<li>Аргументы командной строки, передаваемые docker run, переопределяют аргументы, предоставленные инструкции CMD в Dockerfile.</li>
<li>Лучше устанавливать с помощью WORKDIR абсолютные пути к папкам, а не перемещаться по файловой системе с помощью команд cd в Dockerfile.</li>
<li>Инструкция WORKDIR автоматически создаёт директорию в том случае, если она не существует.</li>
<li>Можно использовать несколько инструкций WORKDIR. Если таким инструкциям предоставляются относительные пути, то каждая из них меняет текущую рабочую директорию.</li>
<li>Если при каждом запуске контейнера нужно выполнять одну и ту же команду — используйте ENTRYPOINT.</li>
<li>Если контейнер будет использоваться в роли приложения — используйте ENTRYPOINT.</li>
<li>Если вы знаете, что при запуске контейнера вам понадобится передавать ему аргументы, которые могут перезаписывать аргументы, указанные в Dockerfile, используйте CMD.</li>
<code>
# Задаём значение по умолчанию для переменной <br>
ARG my_var=my_default_value <br>
# Настраиваем команду, которая должна быть запущена в контейнере во время его выполнения <br>
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
</code>
<li>Инструкция EXPOSE указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Она, скорее, играет роль документации к образу, средством общения того, кто собирает образ, и того, кто запускает контейнер.

Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду docker run с ключом -p. Если использовать ключ в виде -P (с заглавной буквой P), то открыты будут все порты, указанные в инструкции EXPOSE.</li>
</ul>


---------------------------------------------------------------
<p>docker run -it --rm --name my-running-app my-python-app</p>